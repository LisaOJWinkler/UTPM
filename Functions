class Vehicle:
    def __init__(self, body_type, fuel_type, age, mass, china, elec):
        self.body_type = body_type
        self.fuel_type = fuel_type
        self.age = age 
        self.m=mass
        self.c=china
        self.e=elec
        #self.y=y
        #self.emissions = emissions
    
    """
    @property
    def emissions(self):
        if self.fuel_type==1:
            emissions_value=500+5*(self.y-self.age)
        if self.fuel_type==2:
            emissions_value=1000+5*(self.y-self.age)
        return emissions_value
    """
    
    def emissions(self,y):
        emissions_value=0
        phev_electric_emissions=0
        phev_tailpipe_emissions=0
        #if BEV
        if self.fuel_type==4:
            emissions_value=np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[self.e][y-2010])
            #emissions_value=np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[0][y-1989])
        #if petrol
        if self.fuel_type==1:
            #[petrol]=kgCO2/l, [fuel consumption]=l/100km, so *10 gives [emissions]=g/km
            emissions_value=petrol*10*np.array(Fuel_Consumption(self.m).petrol()[self.age-1989])
        #if diesel
        if self.fuel_type==0:
            emissions_value=diesel*10*np.array(Fuel_Consumption(self.m).diesel()[self.age-1989])
        #if hybrid
        if self.fuel_type==2:
            #emissions_value=petrol*10*np.array(Fuel_Consumption(self.m).hybrid()[1][self.age-1989])
            
            emissions_value=0.5*(petrol*10*np.array(Fuel_Consumption(self.m).petrol()[self.age-1989])
                                 +np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[self.e][y-2010]))
            #emissions_value=0.5*(petrol*10*np.array(Fuel_Consumption(self.m).petrol()[self.age-1989])
            #                     +np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[0][y-1989]))
            #real-world PHEV utility factor of 39% as found by the ICCT
            phev_electric_emissions=0.39*np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[self.e][y-2010])
            #phev_electric_emissions=0.5*np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[0][y-1989])
            phev_tailpipe_emissions=0.61*petrol*10*np.array(Fuel_Consumption(self.m).petrol()[self.age-1989])
        #if retrofitted ICEV
        if self.fuel_type==3:
            emissions_value=np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[self.e][y-2010])
            #emissions_value=np.array(Fuel_Consumption(self.m).bev()[self.age-1989])*10*np.array(Fuel_Consumption(self.m).electricity()[0][y-1989])
        
        
        return emissions_value,phev_electric_emissions,phev_tailpipe_emissions
    
    def prod_emissions(self,y):
        #in kg per car (ICE from eu, EVs from china)
        #manufacturing+end-of-life emissions + emissions change with mass + emissions of road construction
        emissions_value=0
        #if BEV
        if self.fuel_type==4:
            #china
            if self.c==1:
                emissions_value=18330+(self.m-1400)*4+4944
            #eu
            elif self.c==0:
                #emissions_value=12080+(self.m-1400)*4
                #half of manufacturing energy gets decarbonised with grid
                emissions_value=4349+(self.m-1400)*4+(48450/3.6)*Fuel_Consumption(self.m).electricity()[self.e][y-2010]+4944       
        #if petrol
        if self.fuel_type==1:
            #emissions_value=11260+(self.m-1400)*4
            emissions_value=2117+(self.m-1400)*4+(34850/3.6)*Fuel_Consumption(self.m).electricity()[self.e][y-2010]+4944
        #if diesel
        if self.fuel_type==0:
            #emissions_value=12115+(self.m-1400)*4
            emissions_value=2117+(self.m-1400)*4+(34850/3.6)*Fuel_Consumption(self.m).electricity()[self.e][y-2010]+4944
        #if hybrid
        if self.fuel_type==2:
            #china
            if self.c==1:
                emissions_value=18490+(self.m-1400)*4+4944
            #eu
            elif self.c==0:
                #emissions_value=12490+(self.m-1400)*4
                emissions_value=2769+(self.m-1400)*4+(42650/3.6)*Fuel_Consumption(self.m).electricity()[self.e][y-2010]+4944
        #if retrofit
        if self.fuel_type==3:
            #china
            if self.c==1:
                emissions_value=8043+4944
            #eu
            elif self.c==0:
                #emissions_value=4575
                emissions_value=2500+(25000/3.6)*Fuel_Consumption(self.m).electricity()[self.e][y-2010]+4944
        return emissions_value
    
    def prod_energy(self):
        #in MJ per car
        #manufacturing+endoflife energy + energy change with mass + energy of road construction
        energy_value=0
        #if BEV
        if self.fuel_type==4:
            energy_value=96900+((self.m-1400)/1400)*0.75*96900+72564
        #if petrol
        if self.fuel_type==1:
            energy_value=69700+((self.m-1400)/1400)*0.8*69700+72564
        #if diesel
        if self.fuel_type==0:
            energy_value=69700+((self.m-1400)/1400)*0.8*69700+72564
        #if hybrid
        if self.fuel_type==2:
            energy_value=85300+((self.m-1400)/1400)*0.75*85300+72564
        #if retrofit
        if self.fuel_type==3:
            energy_value=50000
        return energy_value
        
class Mathematics:
    
    def poly_fit(years,data,power):
        """
        Generate polynomial fit of given data.
        Inputs: x values (usually years), data, power (1 for linear, 2 for quadratic)
        """
        coeff = np.polyfit(years,data,power,cov=False)
        function=sp.poly1d(coeff)
        return(function)
    
    def straight_fit(x1,y1,x2,y2,f):
        """
        Straight fit between two points
        """
        m = (y2 - y1) / (x2 - x1)
        c = (y2 - (m * x2))
        return [i*m+c for i in f]
    
class ModalShare:
    
    def co2intensity(elec):
        
        #non car modal share of london
        modal_walk=[0.39]*31
        modal_cycle=[0.04]*31
        modal_bus=[0.22]*31
        modal_rail=[0.35]*31
        modal_ferry=[0]*31
        
        #at average occupancy
        #co2walk=Mathematics.straight_fit(2019,0.00025,2050,0.00025,range(2020,2051))
        #co2cycle=Mathematics.straight_fit(2019,0.0093,2050,0.0093,range(2020,2051))
        #co2bus=Mathematics.straight_fit(2019,0.21,2050,0.02,range(2020,2051))
        #co2rail=Mathematics.straight_fit(2019,0.02,2050,0.02,range(2020,2051))
        co2ferry=Mathematics.straight_fit(2019,0.2,2050,0.02,range(2020,2051))
        
        #kgco2-eq per passenger kilometer transport (pkt)
        #values based on sustainability paper sustainability-650843-SI
        co2walk=[0.00025]*31
        co2cycle=[0.0094]*31
        #at bus occupancy of 20
        #keeping emissions from manufacture and infrastructure relatively fixed 
        #emissions from energy use per km is straight line between 2020 co2 value and 2050 100% electricity value
        co2bus=np.array([0.023]*31)+Mathematics.straight_fit(2019,0.088,2050, \
                                                             0.319*Fuel_Consumption(1400).electricity()[elec][-1],range(2020,2051))
        #use electricity values for 2020 and 2050
        co2rail=np.array([0.013]*31)+Mathematics.straight_fit(2019,0.15*Fuel_Consumption(1400).electricity()[elec][10],2050, \
                                                             0.15*Fuel_Consumption(1400).electricity()[elec][-1],range(2020,2051))
        
        avg=np.array(modal_walk)*np.array(co2walk)+np.array(modal_cycle)*np.array(co2cycle) \
            +np.array(modal_bus)*np.array(co2bus)+np.array(modal_rail)*np.array(co2rail)+np.array(modal_ferry)*np.array(co2ferry)
        
        return avg
    
    def energy():
        
        #non car modal share of london
        modal_walk=[0.39]*31
        modal_cycle=[0.04]*31
        modal_bus=[0.22]*31
        modal_rail=[0.35]*31
        modal_ferry=[0]*31
        
        #MJ per passenger kilometer transport (pkt)
        #values based on sustainability paper sustainability-650843-SI
        walk=[0.007]*31
        cycle=[0.1524]*31
        #at bus occupancy of 20
        bus=[1.42]*31
        #at train occupancy of 146/200
        rail=[0.751]*31
        
        avg=np.array(modal_walk)*np.array(walk)+np.array(modal_cycle)*np.array(cycle) \
            +np.array(modal_bus)*np.array(bus)+np.array(modal_rail)*np.array(rail)
        
        return avg
    
    def co2intensity_opt():
        
        #optimal modal share
        modal_walk=[0.4]*31
        modal_cycle=[0.25]*31
        modal_bus=[0.1]*31
        modal_rail=[0.25]*31
        modal_ferry=[0]*31
        
        #at high occupancy
        co2walk=Mathematics.straight_fit(2019,0.00025,2050,0.00025,range(2020,2051))
        co2cycle=Mathematics.straight_fit(2019,0.0093,2050,0.0093,range(2020,2051))
        co2bus=Mathematics.straight_fit(2019,0.06,2050,0.02,range(2020,2051))
        co2rail=Mathematics.straight_fit(2019,0.014,2050,0.014,range(2020,2051))
        co2ferry=Mathematics.straight_fit(2019,0.2,2050,0.02,range(2020,2051))
        
        avg=np.array(modal_walk)*np.array(co2walk)+np.array(modal_cycle)*np.array(co2cycle) \
            +np.array(modal_bus)*np.array(co2bus)+np.array(modal_rail)*np.array(co2rail)+np.array(modal_ferry)*np.array(co2ferry)
        
        return avg
        
class Adoption_Rate:
    
    def __init__(self,phase_out_date,phase_out_hybrid):
        """
        Initialises class with data file
        """
        self.p=phase_out_date
        self.ph=phase_out_hybrid
            
        
    def adoption_bev(self):
        
        adoption_bev=[]
        adoption_diesel=Adoption_Rate(self.p,self.ph).adoption_diesel()
        adoption_petrol=Adoption_Rate(self.p,self.ph).adoption_petrol()
        adoption_hybrid=Adoption_Rate(self.p,self.ph).adoption_hybrid()
        adoption_plugin=Adoption_Rate(self.p,self.ph).adoption_plugin()
        
        for i in range(0,62):
            adoption_bev.append(100-adoption_diesel[i]-adoption_petrol[i]-adoption_hybrid[i]-adoption_plugin[i])
        
        return(adoption_bev)
    
        
    def adoption_diesel(self):
        """
        Creates list of adoption rates of diesel cars from 1989 to 2100 in percentage
        Vehicle_Fleet_Sizes(ldn_data, 2030, 1, 0.05).adoption_diesel()
        """
        diesel_increase=Mathematics.poly_fit([2001,2002,2003],adop_car_d[0:3],1)
        diesel_decrease=Mathematics.poly_fit([2017,2018,2019,2020],adop_car_d[16:],1)
        
        #adoption_diesel=[0]*9+diesel_increase(range(1997,2002))+self.d.adop_car_d+diesel_decrease(range(2019,2022))+[0]*79
        
       # d2=diesel_increase(range(1997,2002))
        #print(d2)
        
        #adoption_diesel=[0]*9+self.d.adop_car_d
        #print(adoption_diesel)
        
        adoption_diesel=np.append(np.append(np.append([0]*9,diesel_increase(range(1998,2004))),adop_car_d[3:-4]),np.append(diesel_decrease(range(2017,2023)),[0]*28))
        return(adoption_diesel)

    def adoption_plugin(self):
        
        x=np.linspace(2020,self.ph-1,self.ph-2021)
        
        def gaussian(x, mu, sig):
            return np.exp(-np.power(x - mu, 2.) / (2 * np.power(sig, 2.)))
        if self.ph==2025:
            adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),10*gaussian(x,2020+(self.ph-2020)/2,5)),[0]*(2050-self.ph+1))
        elif self.ph==2030:
            adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),15*gaussian(x,2020+(self.ph-2020)/2,4)),[0]*(2050-self.ph+1))
        elif self.ph==2035:
            adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),20*gaussian(x,2020+(self.ph-2020)/2,6)),[0]*(2050-self.ph+1))
            #adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),40*gaussian(x,2020+(self.ph-2020)/2,4.8)),[0]*(2050-self.ph+1))
            #adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),70*gaussian(x,2035,8)),[0]*(2050-self.ph+1))
        elif self.ph==2040:
            adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),25*gaussian(x,2020+(self.ph-2020)/2,7)),[0]*(2050-self.ph+1))
        else:
            adoption_plugin=np.append(np.append(np.append([0]*12,adop_car_ph),15*gaussian(x,2020+(self.ph-2020)/2,5)),[0]*(2050-self.ph+1))
        
        return(adoption_plugin)
    
    def adoption_hybrid(self):
        
        """
        #4\% increase (growth of diesel) until halfway through phase-out OR until phase-out
        maxi=adop_car_h[-1]+3*(self.p-2020)/2
        increase=Mathematics.straight_fit(2020,adop_car_h[-1],int(2020+(self.p-2020)/2)+1,maxi,range(2021,int(2020+(self.p-2020)/2)+1))
        decrease=Mathematics.straight_fit(int(2020+(self.p-2020)/2)+1,maxi,self.p,0,range(int(2020+(self.p-2020)/2)+1,self.p))
        full=np.append(np.append(np.append(np.append([0]*12,np.array(adop_car_h)),increase),decrease),[0]*(2050-self.p+1))
        """
              
        x=np.linspace(2020,self.p,self.p-2021)
        
        def gaussian(x, mu, sig):
            return np.exp(-np.power(x - mu, 2.) / (2 * np.power(sig, 2.)))
        if self.p==2025:
            adoption_hybrid=np.append(np.append(np.append([0]*12,np.array(adop_car_h)),15*gaussian(x,2020+(self.p-2020)/2,6)),[0]*(2050-self.p+1))
        elif self.p==2030:
            adoption_hybrid=np.append(np.append(np.append([0]*12,np.array(adop_car_h)),20*gaussian(x,2020+(self.p-2020)/2,6)),[0]*(2050-self.p+1))
        elif self.p==2035:
            adoption_hybrid=np.append(np.append(np.append([0]*12,np.array(adop_car_h)),25*gaussian(x,2020+(self.p-2020)/2,7)),[0]*(2050-self.p+1))
        elif self.p==2040:
            adoption_hybrid=np.append(np.append(np.append([0]*12,np.array(adop_car_h)),30*gaussian(x,2020+(self.p-2020)/2,9)),[0]*(2050-self.p+1))
        else:
            adoption_hybrid=np.append(np.append(np.append([0]*12,np.array(adop_car_h)),20*gaussian(x,2020+(self.p-2020)/2,6)),[0]*(2050-self.p+1))
            
        return(adoption_hybrid)
    
    def adoption_petrol(self):
        
        decline=Mathematics.straight_fit(2020,adop_car_p[-1],self.p,0,range(2021,self.p))
        
        diesel_increase=[100]*3-np.array(Mathematics.poly_fit([2001,2002,2003],adop_car_d[0:3],1)(range(1998,2001)))
        
        full=np.append(np.append(np.append(np.append([100]*9,diesel_increase),adop_car_p),decline),[0]*(2050-self.p+1))
        
        x=np.linspace(2020,self.p-1,self.p-2020)
        
        
        def gaussian(x, mu, sig):
            return np.exp(-np.power(x - mu, 2.) / (2 * np.power(sig, 2.)))
        
        if self.p==2025:
            adoption_petrol=np.append(np.append(np.append([100]*12,adop_car_p),80*gaussian(x,2020+(self.p-2020)/4,3)),[0]*(2050-self.p+1))
        elif self.p==2030:
            adoption_petrol=np.append(np.append(np.append([100]*12,adop_car_p),80*gaussian(x,2020+(self.p-2020)/4,5)),[0]*(2050-self.p+1))
        elif self.p==2035:
            adoption_petrol=np.append(np.append(np.append(np.append(np.append([100]*12,adop_car_p),80*gaussian(np.linspace(2020,2021,2),2021,3)),[80]*3),80*gaussian(np.linspace(2025,2034,10),2025,5)),[0]*(2050-self.p+1))
        elif self.p==2040:
            adoption_petrol=np.append(np.append(np.append(np.append(np.append([100]*12,adop_car_p),80*gaussian(np.linspace(2020,2021,2),2021,3)),[80]*8),80*gaussian(np.linspace(2030,2039,10),2030,5)),[0]*(2050-self.p+1))
        else:
            adoption_petrol=np.append(np.append(np.append([100]*12,adop_car_p),80*gaussian(x,2020+(self.p-2020)/4,9)),[0]*(2050-self.p+1))
            
            
        return(full)

    
class Fuel_Consumption:
    """
    Fuel_Consumption(2030,1,0.05).petrol()
    """
    
    def __init__(self,mass):
        """
        Initialises class with data file
        """
        self.m=mass
        
    def petrol(self):
        
        pre_1997=Mathematics.poly_fit([1997,1998,1999],fuel_car_p[0:3],1)
        
        #post_2020_typ=Mathematics.straight_fit(2020,fuel_car_p[-1],2050,4.5,range(2020,2051))
        #post_2020_suv=Mathematics.straight_fit(2020,fuel_car_p[-1],2050,8.7,range(2020,2051))
        
        post_2020=np.append(Mathematics.straight_fit(2020,fuel_car_p[-1],2025,fuel_car_p[-1]+(self.m-1400)*0.0032,range(2020,2026)),
                            [fuel_car_p[-1]+(self.m-1400)*0.0032]*25)
        
        #fuel_petrol_typ=np.append(pre_1997(range(1989,2000)),np.append(fuel_car_p[3:],post_2020_typ))
        #fuel_petrol_suv=np.append(pre_1997(range(1989,2000)),np.append(fuel_car_p[3:],post_2020_suv))
        
        return np.append(pre_1997(range(1989,2000)),np.append(fuel_car_p[3:],post_2020))
        
    def diesel(self):
        
        pre_1997=Mathematics.poly_fit([1997,1998,1999],fuel_car_d[0:3],1)
        
        #post_2020_typ=Mathematics.straight_fit(2020,fuel_car_d[-1],2050,3.3,range(2020,2051))
        #post_2020_suv=Mathematics.straight_fit(2020,fuel_car_d[-1],2050,6.5,range(2020,2051))
        
        post_2020=np.append(Mathematics.straight_fit(2020,fuel_car_d[-1],2025,fuel_car_d[-1]+(self.m-1400)*0.0028,range(2020,2026)),
                            [fuel_car_d[-1]+(self.m-1400)*0.0028]*25)
        
        #fuel_diesel_typ=np.append(pre_1997(range(1989,2000)),np.append(fuel_car_d[3:],post_2020_typ))
        #fuel_diesel_suv=np.append(pre_1997(range(1989,2000)),np.append(fuel_car_d[3:],post_2020_suv))
        
        return np.append(pre_1997(range(1989,2000)),np.append(fuel_car_d[3:],post_2020))
    
    def hybrid(self):
        
        #hybrid=(0.5*(np.array(Fuel_Consumption().petrol())+np.array(Fuel_Consumption().diesel())))
        
        
        official=[1.66]*62
        realworld=[4.4]*62
        return official,realworld
    
    def bev(self):
        
        #bev=Mathematics.straight_fit(2020,15,2050,10,range(2020,2051))
        
        bev=np.append([18]*31,np.append(Mathematics.straight_fit(2020,18,2025,18+(self.m-1400)*0.01,range(2020,2026)),[18+(self.m-1400)*0.01]*25))
        #bev=[18]*62
        
        return(bev)
    
    def electricity(self):
        
        #in kgco2/kwh
        #projection=Mathematics.straight_fit(2020,elec_emissions[-1],2050,0.029,range(2021,2051))
        projection1=Mathematics.straight_fit(2020,elec_emissions[-1],2025,0.095,range(2021,2026))
        projection2=Mathematics.straight_fit(2025,0.095,2035,0.025,range(2026,2036))
        projection3=Mathematics.straight_fit(2035,0.025,2050,0.01,range(2036,2051))
        genemissions=(np.append(np.append(np.append(elec_emissions,projection1),projection2),projection3))
        
        #lca analysis 2060 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2034,0.154,range(2020,2034))
        projection3=Mathematics.straight_fit(2034,0.154,2048,0.083,range(2034,2048))
        projection4=Mathematics.straight_fit(2048,0.083,2060,0.019,range(2048,2051))
        lcaemissions_2060=(np.append(np.append(np.append(projection1,projection2),projection3),projection4))+0.011
        
        #lca analysis 2055 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2032,0.154,range(2020,2032))
        projection3=Mathematics.straight_fit(2031,0.154,2044,0.083,range(2031,2044))
        projection4=Mathematics.straight_fit(2044,0.083,2055,0.019,range(2044,2051))
        lcaemissions_2055=(np.append(np.append(np.append(projection1,projection2),projection3),projection4))+0.011
        
        #lca analysis 2050 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2030,0.154,range(2020,2030))
        projection3=Mathematics.straight_fit(2030,0.154,2040,0.083,range(2030,2040))
        projection4=Mathematics.straight_fit(2040,0.083,2050,0.019,range(2040,2051))
        lcaemissions_2050=(np.append(np.append(np.append(projection1,projection2),projection3),projection4))+0.011
        
        #lca analysis 2045 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2028,0.154,range(2020,2028))
        projection3=Mathematics.straight_fit(2028,0.154,2036,0.083,range(2028,2036))
        projection4=Mathematics.straight_fit(2036,0.083,2045,0.019,range(2036,2045))
        projection5=Mathematics.straight_fit(2045,0.019,2050,0.019,range(2045,2051))
        lcaemissions_2045=(np.append(np.append(np.append(np.append(projection1,projection2),projection3),projection4),projection5))+0.011
        
        #lca analysis 2040 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2027,0.154,range(2020,2027))
        projection3=Mathematics.straight_fit(2027,0.154,2034,0.083,range(2027,2034))
        projection4=Mathematics.straight_fit(2034,0.083,2040,0.019,range(2034,2040))
        projection5=Mathematics.straight_fit(2040,0.019,2050,0.019,range(2040,2051))
        lcaemissions_2040=(np.append(np.append(np.append(np.append(projection1,projection2),projection3),projection4),projection5))+0.011
        
        #lca analysis 2035 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2025,0.154,range(2020,2025))
        projection3=Mathematics.straight_fit(2025,0.154,2030,0.083,range(2025,2030))
        projection4=Mathematics.straight_fit(2030,0.083,2035,0.019,range(2030,2035))
        projection5=Mathematics.straight_fit(2035,0.019,2050,0.019,range(2030,2051))
        lcaemissions_2035=(np.append(np.append(np.append(np.append(projection1,projection2),projection3),projection4),projection5))+0.011
        
        #lca analysis 2030 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2024,0.154,range(2020,2024))
        projection3=Mathematics.straight_fit(2024,0.154,2027,0.083,range(2024,2027))
        projection4=Mathematics.straight_fit(2027,0.083,2030,0.019,range(2027,2030))
        projection5=Mathematics.straight_fit(2030,0.019,2050,0.019,range(2030,2051))
        lcaemissions_2030=(np.append(np.append(np.append(np.append(projection1,projection2),projection3),projection4),projection5))+0.011
    
        #lca analysis 2025 'net-zero' case
        projection1=Mathematics.straight_fit(2010,0.608,2020,0.303,range(2010,2020))
        projection2=Mathematics.straight_fit(2020,0.303,2022,0.154,range(2020,2022))
        projection3=Mathematics.straight_fit(2022,0.154,2024,0.083,range(2022,2024))
        projection4=Mathematics.straight_fit(2024,0.083,2025,0.019,range(2024,2025))
        projection5=Mathematics.straight_fit(2025,0.019,2050,0.019,range(2025,2051))
        lcaemissions_2025=(np.append(np.append(np.append(np.append(projection1,projection2),projection3),projection4),projection5))+0.011
        
        return genemissions,lcaemissions_2060,lcaemissions_2055,lcaemissions_2050,lcaemissions_2045,lcaemissions_2040,lcaemissions_2035,lcaemissions_2030,lcaemissions_2025
        
class Distance_Driven:
    """
    Calculates distance driven by average car by dividing total km driven by whole fleet from data with number of fleet in data
    """
    
    def __init__(self,miles_driven):
        """
        Initialises class with data file
        """
        self.md=miles_driven
    
    def Lon(self):
        """
        if self.f==0:
            projection=Mathematics.straight_fit(2020,km_lon[-1],2050,km_lon[-1],range(2020,2052))
        elif self.f==1:
            projection=Mathematics.straight_fit(2020,km_lon[-1],2050,32,range(2020,2052))
        elif self.f==-1:
            projection=Mathematics.straight_fit(2020,km_lon[-1],2050,23,range(2020,2052))
        """
        if self.md==-43:
            preprojection=Mathematics.straight_fit(2020,km_lon[-1],2022,km_lon[-1],range(2020,2022))
            projection=Mathematics.straight_fit(2022,km_lon[-1],2041,km_lon[-1]*(1-0.43),range(2022,2041))
            postprojection=Mathematics.straight_fit(2041,km_lon[-1]*(1-0.43),2050,km_lon[-1]*(1-0.43),range(2041,2052))
        
        if self.md==-0.1:
            preprojection=Mathematics.straight_fit(2020,km_lon[-1],2022,km_lon[-1],range(2020,2022))
            projection=Mathematics.straight_fit(2022,km_lon[-1],2024,km_lon[-1]*(1-0.81),range(2022,2024))
            postprojection=Mathematics.straight_fit(2024,km_lon[-1]*(1-0.81),2050,km_lon[-1]*(1-0.81),range(2024,2052))
            
        else:
            preprojection=Mathematics.straight_fit(2020,km_lon[-1],2022,km_lon[-1],range(2020,2022))
            projection=Mathematics.straight_fit(2022,km_lon[-1],2027,km_lon[-1]*(1+self.md/100),range(2022,2027))
            postprojection=Mathematics.straight_fit(2027,km_lon[-1]*(1+self.md/100),2050,km_lon[-1]*(1+self.md/100),range(2027,2052))
        return np.append(np.append(np.append(np.array(km_lon),preprojection),projection),postprojection)
    
    def twenty(self):
        
        projection=Mathematics.straight_fit(2020,km_lon[-1],2050,km_lon[-1]*1.2,range(2020,2052))
        return np.append(km_lon,projection)
    
    def age_distribution(self):
        x=np.array(range(0,31))
        y=(x**2-60*x+900)/900
        area_under=np.trapz(y,x)
        return y/area_under
        
